배열(Array)-2.md
=======================
# 2. enhanced for문
## 2.1. enhanced for문의 이해와 활용
```enhanced for문``` 또는 ```for-each 문```은   
배열에 저장된 모든 요소를 대상으로 연산, 참조 또는 탐색을 진행할 때 사용한다 . 
     
**일반 for** 
```
int [] ar = {1, 2, 3, 4, 5};
for(int i = 0; i < ar.length; i++){
  Sytem.out.println(ar[i]);
}
```
     
**enhanced for문**
```
int [] ar = {1, 2, 3, 4, 5};
for(int e : ar){
  Sytem.out.println(e);
}
```   
위 코드들을 비교했을 때는 별 차이가 나지 않는 것 같지만 코드의 양이 많고 복잡할 경우 둘의 차이가 확연히 들어난다.       
```enhanced for문```의 장점은 아래와 같다.     
      
* 코드의 양이 절대적으로 줄어든다.      
* 반복문 구성 과정에서 배열의 길이 정보를 직접 확인하고 입력할 필요가 없다.      
      
확실히 일반적인 ```for() 문```보다는 작성하는 내용은 적다는 것을 알 수가 있다.      
각각의 요소를 위한 인덱스 변수(```int i```)를 생성할 필요가 없으며 반복 조건, 증감 연산자도 정의하지 않는다.       
     
단, ```enhanced for문```는 모든 요소에 대한 반복문을 사용하고 할 때 사용하므로 부분적으로는 불가능하다.      
   
**enhanced for문 구조**  
```
for(요소 : 배열){
  반복할 문장들
}
```
    
## 2.2. 인스턴스 배열을 대상으로 하는 enhanced for 문
배열에 저장된 값이 '인스턴스' 즉 객체인 경우에도 ```enhanced for 문```을 사용할 수 있다.     
즉 구성요소가 인스턴스(객체)로 이루어진 클래스 배열에서도 사용이 가능하다.  
```
Box[] boxArr = new Box[10];
for(Box e : boxArr){
...
}
```
객체를 요소로 사용할 수 있다는 얘기는      
객체를 ```print``` 출력하는 것이 아니락 객체를 조작한다고 생각을 해야 헷갈리지 않는다.    
     
## 2.3. 다차원 배열의 이해와 활용   
배열의 논리적 메모리 구조가 2차원 이상의 형태를 보이는 배열을 가리켜 '다차원 배열'이라 한다.       
즉, 2차원 배열도 다차원 배열이고 3차원 배열도 다차원 배열이다.        
     
### 2.3.1. 2차원 배열의 생성과 접근
1차원 배열은 둘 이상의 변수가 '선의 형태'로 존재하는 배열이라면     
2차원 배열은 다수의 변수가 '면의 형태'로 존재하는 배열이다.    
```
int[][] arr = new int[3][4];
// 세로의 길이가 3 가로의 길이가 4인 배열

/*   
     [0][0], [0][1], [0][2], [0][3]
     [1][0], [1][1], [1][2], [1][3]
     [2][0], [2][1], [2][2], [2][3]
*/
```

### 2.3.2. 2차원 배열의 구조-1
다차원 배열은 일반 배열과 ```length``` 부분에서 크게 차이가 난다.   
```
int[][] test4 = new int[3][4];
System.out.println(test4.length);       // 결과는 3
```
위와 같이 2차원 배열 자체에 저장된 ```length```상수의 값은 2차원 배열의 세로의 길이를 의미한다.  
이러한 이유는 각각의 세로 변수가 가로 변수들(가로변수 배열)을 참조하기 때문이다.    
```
[0]   -> 참조 ->   [0][0], [0][1], [0][2], [0][3]
[1]   -> 참조 ->   [1][0], [1][1], [1][2], [1][3]
[2]   -> 참조 ->   [2][0], [2][1], [2][2], [2][3]
```
그렇기에 세로 길이 뿐만 아니라 가로 길이를 알고자 한다면 첫번째 인덱스만 사용하여 가로의 길이를 구할 수 있다.  
```
int[][] arr = new arr[3][4];
System.out.println(arr.length);         // 3 출력

System.out.println(arr[0].length);      // 4 출력
System.out.println(arr[1].length);      // 4 출력
System.out.println(arr[2].length);      // 4 출력
```
만약 전체 크기를 구하고자 하다면 ```for 문```을 이용해서 구하는 방법이 있다.  
```
int sum = 0;
int[][] arr = new int[3][4];
for(int i=0; i < arr.length; i++){
     for(int j=-0; j < arr[i].length; j++){
          sum += 1;
     }
}
System.out.println(sum); // 12 출력
```
물론 이를 응용해서 다차원 배열의 요소의 값들의 합을 구하거나 하는 동작도 취할 수 있다.    
  
### 2.3.2. 2차원 배열의 구조-2
앞서 이차원 구조에서 각 세로의 변수들은 가로 변수들의 모음을 참조한다고 했다.   
여기서 중요한 것은 **참조**이다.  
  
각 세로의 변수들은 가로 변수들의 모음을 참조하기에  
이를 다르게 생각하면 세로 변수도 일종의 참조 변수이므로 다른 가로 변수들의 모음을 참조 할 수 있다는 뜻이고  
이를 토대로 특정 세로 인덱스 부분의 가로 변수의 길이를 다른 가로 변수들의 길이와 달리 할 수 있다.  
```
int[][] arr = new int[3][4];
...
arr[1] = new int[7];
...
/*
     [0]   -> 참조 ->   [0][0], [0][1], [0][2], [0][3]
     [1]   -> 참조 ->   [1][0], [1][1], [1][2], [1][3], [1][4], [1][5], [1][6]
     [2]   -> 참조 ->   [2][0], [2][1], [2][2], [2][3]
*/
```

C언어에서는 각 배열의 가로의 크기가 모두 일정하지만       
JAVA 에서는 참조를 활용하여 가로의 크기를 모두 다르게도 할 수 있다.       
  
### 2.3.3. 2차원 배열의 초기화
2차원 배열도 1차원 배열처럼 초기화와 동시에 생성도 가능하다.  
```
1차원 배열 초기화 및 생성)

int[3] arr = {1, 2, 3};
________________________________________________________
2차원 배열 초기화 및 생성 -일반)

int[][] arr = new int[3][4]{
     {1, 2, 3, 4},
     {5, 6, 7, 8},
     {9, 10, 11, 12}
};
________________________________________________________
2차원 배열 초기화 및 생성 -간략)

int[][] arr = {
     {1, 2, 3, 4},
     {5, 6, 7, 8},
     {9, 10, 11, 12}
};
________________________________________________________
2차원 배열 초기화 및 생성 -가변길이)

int[][] arr = {
     {11},
     {22, 33},
     {44, 55, 66};
```  
