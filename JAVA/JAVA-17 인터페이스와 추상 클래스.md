인터페이스와 추상 클래스
=======================
# 1. 인터페이스
## 1.1. 구조와 특징
  
**인터페이스 구조**
```
interface InterfaceNmae{
  public void interfaceMethod(String doc);
}
```
인터페이스는 메소드의 몸체가 비어있는 **추상 메소드**를 가지고 있다.  
그리고 인터페이스는 추상 메소드 같이 정의가 완벽히 되어있지 않는 멤버를 갖기에 인스턴스로 생성할 수 없다.  
다만 클래스에 구현(상속)될 수 있고 해당 클래스에서는 추상메소드를 오버라이딩해서 사용하면 된다.    

```
class Printer implements Printable{
  public void printMethod(String doc){
    System.out.println("print!");
  }
}
```
  
* 구현할 인터페이스를 명시할 때 키워드 implements를 사용한다.    
* 한 클래스는 둘 이상의 인터페이스를 동시에 구현할 수 있다. (다중 구현 가능)    
* 상속과 구현은 동시에 가능하다.    
  
**인터페이스 관련한 특징 2가지**  
  
* 인터페이스의 형을 대상으로 참조변수의 선언이 가능하다.
* 인터페이스의 추상 메소드와 이를 구현하는 메소드 사이에 오버라이딩 관계가 성립한다.     
따라서 어노테이션```@Overrid```의 선언이 가능하다.    
   
**인터페이스와 참조**
인터페이스는 참조형 변수의 자료형이 될 수 있다.  
``` 
Printable printable = new Printer()       // Printable을 구현한 Printer 인스턴스 참조 가능
Printable printable = new Printerable()       // X 불가 -> 인터페이스는 인스턴스 생성 불가능
```
단, 위에서 보이듯이 인터페이스를 구현한 인스턴스에 한해서만 가능하고    
다형성의 원칙처럼 인터페이스에 관련된 메소드만 사용할 수 있다.(메소드는 오버라이딩 되어있다.)   
  
인터페이스는 인스턴스를 생성할 수 없으니 인터페이스를 직접 참조가 불가능하다.     

### 1.2. 인터페이스의 본질적 의미
'인터페이스'의 사전적 의미는 '연결점' 또는 '접점'으로 둘 사이를 연겨랗는 매개체를 뜻한다.  
이제부터는 예시를 통해 설명하겠다.   
  
**Printable 인터페이스**
```
interface Printerble{
  public void print(String doc);
}
```
**S 회사**
```
class SPrinterDriver implements Printable{
  @Override
  public void print(String doc){
    System.out.println("S 회사 프린터");
    System.out.println(doc);
  }
}
```
**L 회사**
```
class SPrinterDriver implements Printable{
  @Override
  public void print(String doc){
    System.out.println("L 회사 프린터");
    System.out.println(doc);
  }
}
```
```Printable 인터페이스```를 각각 ```S 회사 클래스```와 ```L 회사 클래스```에 구현시켰다.   
그리고 각각 ```print()```메소드를 정의해서 각자의 클래스만의 독자적인 메소드를 생성해냈다.  
  
결론은 이렇다. 어떠한 하나의 공통 규약을 주면 이를 통해 각각의 클래스는 자신만의 메소드를 정의할 수 있다.  
  
그리고 위 예시를 통해 운영체제 회사에서는 각각의 프린터 회사에 맞게 시스템을 적용해줄 필요가 없이  
단순히 사용하고자 하는 회사의 클래스만 사용하면 알아서 해당 클래스에 정의된 print가 동작하게 될 것이다.   

# 2. 인터페이스의 문법 구성과 추상 클래스
인터페이스에는 메소드가 정의되어있지 않는 '추상 메소드' 뿐만 아니라     
메소드가 정의된 '디폴트 메소드', 'static 메소드'도 존재한다.     
    
## 2.1. 추상 메소드 특징   
'추상 메소드'에는 한가지 특징이 있다.     
```   
인터페이스의 모든 메소드는 public이 선언 된 것으로 간주한다.  
```
즉, **인터페이스 내에 위치하는 메소드는 별도의 선언이 없어도 public이 된다.**       
       
## 2.2. 인터페이스에 선언되는 메소드와 변수  
인터페이스에도 **변수를 선언 할 수 있다.**  
```
interface Pirntable{
  int PAPER_WIDTH = 170;      // public static final int PAPER_WIDTH = 170;
  int PAPER_HEIGHT = 120;     // public static final int PAPER_HEIGHT = 120;
  void print(String doc);
}
```
인터 페이스 내에 선언되는 변수에는 다음의 특징이 있다.     
      
* 반드시 선언과 동시에 값으로 초기화를 해야 한다.       
* 모든 변수는 ```public```, ```static```, ```final``` 이 선언된 것으로 간주한다.      
     
즉 어디에서나 ```interface.변수``` 로 사용은 가능하지만 '상수'이므로 값 변경은 불가이다.      
그리고 값을 초기화 해야 하는 이유는 초기화 하지 않았을 경우 그냥 정의한 것과 비슷하기 때문이다.      
  
## 2.3. 추상 클래스
일반적인 클래스에도 추상 메소드를 정의할 수 있다.       
하지만 이럴 경우 완벽히 정의되지 않은 멤버가 존재하므로 인터페이스와 마찬가지로 **인스턴스 생성이 불가능하다.**    
     
그렇다면 왜 사용하는 것일까?     
이유는 인터페이스 만으로는 공통으로 정의된 규약을 정의할 수 없기에 이를 클래스로 만들어서 상속하기 위함이다.    
```
class AbsClass {
  public void absMethod(){}
}
```

## 2.4. 인터페이스 간 상속
우선 간단한 예시로 설명을 하겠다.  
기존에 프린터는 '흑백 프린터'였다.  
그런데 어느날 기술의 발전으로 '컬러 프린터'가 등장을 했다.  
그러면 이제 '흑백 프린터'와 '컬러 프린터'가 존재를 하게 된다.  
그리고 이에 맞춰서 'Printable 인터페이스'에도 '컬러 프린터'에 대한 변화가 생겨야 한다.  


***
# 2. 대주제
> 인용
## 2.1. 소 주제
### 2.1.1. 내용1
```
내용1
```   

***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
