인터페이스와 추상 클래스
=======================
# 1. 인터페이스
## 1.1. 구조와 특징
  
**인터페이스 구조**
```
interface InterfaceNmae{
  public void interfaceMethod(String doc);
}
```
인터페이스는 메소드의 몸체가 비어있는 **추상 메소드**를 가지고 있다.  
그리고 인터페이스는 추상 메소드 같이 정의가 완벽히 되어있지 않는 멤버를 갖기에 인스턴스로 생성할 수 없다.  
다만 클래스에 구현(상속)될 수 있고 해당 클래스에서는 추상메소드를 오버라이딩해서 사용하면 된다.    

```
class Printer implements Printable{
  public void printMethod(String doc){
    System.out.println("print!");
  }
}
```
  
* 구현할 인터페이스를 명시할 때 키워드 implements를 사용한다.    
* 한 클래스는 둘 이상의 인터페이스를 동시에 구현할 수 있다. (다중 구현 가능)    
* 상속과 구현은 동시에 가능하다.    
  
**인터페이스 관련한 특징 2가지**  
  
* 인터페이스의 형을 대상으로 참조변수의 선언이 가능하다.
* 인터페이스의 추상 메소드와 이를 구현하는 메소드 사이에 오버라이딩 관계가 성립한다.     
따라서 어노테이션```@Overrid```의 선언이 가능하다.    
   
**인터페이스와 참조**
인터페이스는 참조형 변수의 자료형이 될 수 있다.  
``` 
Printable printable = new Printer()       // Printable을 구현한 Printer 인스턴스 참조 가능
Printable printable = new Printerable()       // X 불가 -> 인터페이스는 인스턴스 생성 불가능
```
단, 위에서 보이듯이 인터페이스를 구현한 인스턴스에 한해서만 가능하고    
다형성의 원칙처럼 인터페이스에 관련된 메소드만 사용할 수 있다.(메소드는 오버라이딩 되어있다.)   
  
인터페이스는 인스턴스를 생성할 수 없으니 인터페이스를 직접 참조가 불가능하다.     

### 1.2. 인터페이스의 본질적 의미
'인터페이스'의 사전적 의미는 '연결점' 또는 '접점'으로 둘 사이를 연겨랗는 매개체를 뜻한다.  
이제부터는 예시를 통해 설명하겠다.   
  
**Printable 인터페이스**
```
interface Printerble{
  public void print(String doc);
}
```
**S 회사**
```
class SPrinterDriver implements Printable{
  @Override
  public void print(String doc){
    System.out.println("S 회사 프린터");
    System.out.println(doc);
  }
}
```
**L 회사**
```
class SPrinterDriver implements Printable{
  @Override
  public void print(String doc){
    System.out.println("L 회사 프린터");
    System.out.println(doc);
  }
}
```
```Printable 인터페이스```를 각각 ```S 회사 클래스```와 ```L 회사 클래스```에 구현시켰다.   
그리고 각각 ```print()```메소드를 정의해서 각자의 클래스만의 독자적인 메소드를 생성해냈다.  
  
결론은 이렇다. 어떠한 하나의 공통 규약을 주면 이를 통해 각각의 클래스는 자신만의 메소드를 정의할 수 있다.  
  
그리고 위 예시를 통해 운영체제 회사에서는 각각의 프린터 회사에 맞게 시스템을 적용해줄 필요가 없이  
단순히 사용하고자 하는 회사의 클래스만 사용하면 알아서 해당 클래스에 정의된 print가 동작하게 될 것이다.   

# 2. 인터페이스의 문법 구성과 추상 클래스
인터페이스에는 메소드가 정의되어있지 않는 '추상 메소드' 뿐만 아니라     
메소드가 정의된 '디폴트 메소드', 'static 메소드'도 존재한다.     
    
## 2.1. 추상 메소드 특징   
'추상 메소드'에는 한가지 특징이 있다.     
```   
인터페이스의 모든 메소드는 public이 선언 된 것으로 간주한다.  
```
즉, **인터페이스 내에 위치하는 메소드는 별도의 선언이 없어도 public이 된다.**       
       
## 2.2. 인터페이스에 선언되는 메소드와 변수  
인터페이스에도 **변수를 선언 할 수 있다.**  
```
interface Pirntable{
  int PAPER_WIDTH = 170;      // public static final int PAPER_WIDTH = 170;
  int PAPER_HEIGHT = 120;     // public static final int PAPER_HEIGHT = 120;
  void print(String doc);
}
```
인터 페이스 내에 선언되는 변수에는 다음의 특징이 있다.     
      
* 반드시 선언과 동시에 값으로 초기화를 해야 한다.       
* 모든 변수는 ```public```, ```static```, ```final``` 이 선언된 것으로 간주한다.      
     
즉 어디에서나 ```interface.변수``` 로 사용은 가능하지만 '상수'이므로 값 변경은 불가이다.      
그리고 값을 초기화 해야 하는 이유는 초기화 하지 않았을 경우 그냥 정의한 것과 비슷하기 때문이다.      
  
## 2.3. 추상 클래스
일반적인 클래스에도 추상 메소드를 정의할 수 있다.       
하지만 이럴 경우 완벽히 정의되지 않은 멤버가 존재하므로 인터페이스와 마찬가지로 **인스턴스 생성이 불가능하다.**    
     
그렇다면 왜 사용하는 것일까?     
이유는 인터페이스 만으로는 공통으로 정의된 규약을 정의할 수 없기에 이를 클래스로 만들어서 상속하기 위함이다.    
```
class AbsClass {
  public void absMethod(){}
}
```
  
## 2.4. 인터페이스 간 상속
우선 간단한 예시로 설명을 하겠다.  
기존에 프린터는 '흑백 프린터'였다.  
그런데 어느날 기술의 발전으로 '컬러 프린터'가 등장을 했다.  
그러면 이제 '흑백 프린터'와 '컬러 프린터'가 존재를 하게 된다.  
그리고 이에 맞춰서 'Printable 인터페이스'에도 '컬러 프린터'에 대한 변화가 생겨야 한다.  
 
여기서 중요한 점은 '흑백 프린터'와 '컬러 프린터'가 존재를 하게 된다.  
그래서 기존 ```Printerble```인터페이스에 컬러 프린터에 관한 메소드를 정의 할 수 있지만  
모든 '흑백 프린터'에서 사용하지도 않는 '컬러 프린터 메소드'를 가지고 있는 것이기에 이는 매우 불필요하다.  
  
자바에서는 인터페이스간의 상속도 지원을 해준다.     
그래서 이를 이용해서 기존에 '흑백 프린터'들은 코드를 변경할 필요도 없고      
'컬러 프린터'는 컬러 프린터 인터페이스를 이용하여 생성만 하면 된다.     
그리고 필요에 따라서는 흑백 프린터 인터페이스의 참조변수에도 사용할 수도 있다.    

이를 코드로 나타내면 이렇다.
```
interface Printerble{
  public void print(String doc);
}

interface ColorPrintable extends Printable {
  public void printCMYK(String doc);
}
```
이제 ```extends```와 ```implements```가 헷갈릴 수 있으니 정리 한번 하겠다.     
    
* 클래스-클래스간의 상송 : extends     
* 인터페이스-인터페이스간의 상속 : extends  
* 클래스-인터페이스간의 구현 : implements   
     
## 2.5. 인터페이스의 디폴트 메소드
앞서 인터페이스의 상속에 대해서 배워봤다.     
하지만 만약 모든 코드에 대하여 기존 인터페이스 대신에 새롭게 상속하여 구현한 인터페이스를 사용해야 한다면      
기존 인터페이스를 사용하는 모든 코드를 찾아서 일일이 수정을 해야할 것이다.      
그리고 이를 인터페이스 상속으로 해결하면 모든 코드에서 인터페이스의 개수는 2배씩 늘어날 것이다.         
      
우리는 이같은 경우가 비효율적인 것을 알고 있다.      
이는 자바 개발자들도 알고 있는 문제사항이었다.        
그래서 자바8에서는 인터페이스 내에서도 정의된 메소드를 사용할 수 있게 하였고      
이것이 바로 **디폴트 메소드** 이다.      
        
**디폴트 메소드 특징**    
   
* 자체로 완전한 메소드이다.    
* 따라서 이를 구현하는 클래스가 오버라이딩 하지 않아도 된다.    
   
'디폴트 메소드'는 인터페이스의 목적에 맞지 않는 예외적인 상황이라는 것을 알 수 있다.    
  
**디폴트 메소드 구조**
```
default void defaultMethod(매개변수){
  ... 코드정의 ...
}
```
방법은 간단하다 기존 메소드에 ```default```키워드만 붙이면 되고 접근 제한은 ```public```이다.     
   
'디폴트 메소드'는 이미 정의 되어있는 메소드이기에 따로 오버라이딩을 안해도 되고     
이는 구현을 하는 클래스의 입장에서는 따로 메소드에 대한 정의를 하지 않아도 된다.    
그리고 기존 코드에서 디폴트 메소드를 추가한다면 메소드에 대한 오버라이딩 정의를 하지 않아도 되니       
이전에 구현된 프로세스에서 사용을 하지 않는 이상 크일반적으로 크게 영향을 주지 않는다.       
  
하지만 디폴트 메소드는 예외 상황이지 무조건적으로 사용하는 것은 옳지 않다.   



***
# 2. 대주제
> 인용
## 2.1. 소 주제
### 2.1.1. 내용1
```
내용1
```   

***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
